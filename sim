# # Cosine similarity And Euclidean Case

# MinHash using permutation + Other Similarities

# import random
# import numpy as np
# from numpy.linalg import norm

# # Example documents
# docs = [
#     "the cat sat on the mat",
#     "the dog sat on the mat",
#     "the cat chased the dog"
# ]

# # Step 1: Shingling (k=2 or 3)
# def get_shingles(doc, k=2):
#     words = doc.split()
#     return {" ".join(words[i:i+k]) for i in range(len(words)-k+1)}

# k = 2
# shingle_set = set()
# doc_shingles = []

# for d in docs:
#     sh = get_shingles(d, k)
#     doc_shingles.append(sh)
#     shingle_set |= sh

# shingles = list(shingle_set)

# # Step 2: Build binary shingle–document matrix
# matrix = []
# for sh in shingles:
#     row = [1 if sh in doc_shingles[j] else 0 for j in range(len(docs))]
#     matrix.append(row)

# sd_matrix = np.array(matrix)

# print("Shingle–Document Matrix:")
# print(sd_matrix)

# # --- Similarity Measures ---

# def cosine_sim(v1, v2):
#     return np.dot(v1, v2) / (norm(v1) * norm(v2))

# def euclidean_dist(v1, v2):
#     return norm(v1 - v2)

# def jaccard_sim(v1, v2):
#     intersection = np.sum(np.logical_and(v1, v2))
#     union = np.sum(np.logical_or(v1, v2))
#     return intersection / union if union != 0 else 0.0

# # Step 3: Pairwise similarities
# for i in range(len(docs)):
#     for j in range(i+1, len(docs)):
#         v1, v2 = sd_matrix[:, i], sd_matrix[:, j]
#         print(f"\nDoc{i+1} vs Doc{j+1}:")
#         print("  Cosine Similarity   =", cosine_sim(v1, v2))
#         print("  Euclidean Distance  =", euclidean_dist(v1, v2))
#         print("  Jaccard Similarity  =", jaccard_sim(v1, v2))


import numpy as np
from numpy.linalg import norm

# Example documents
docs = [
    "this is a cat",
    "this is a dog",
    "cats and dogs are animals",
    "the dog chased the cat"
]

# Step 1: Vocabulary
words = list(set(" ".join(docs).split()))

# Step 2: Term Frequency (TF)
tf = []
for d in docs:
    row = [d.split().count(w) for w in words]
    tf.append(row)
tf = np.array(tf)

# Step 3: Inverse Document Frequency (IDF)
N = len(docs)
idf = np.log(N / (np.count_nonzero(tf, axis=0)))

# Step 4: TF-IDF
tfidf = tf * idf
print("TF-IDF Matrix:\n", tfidf)

# Step 5: Pairwise Cosine Similarity and Euclidean Distance
num_docs = len(docs)

print("\nCosine Similarities:")
for i in range(num_docs):
    for j in range(i+1, num_docs):
        cosine_sim = np.dot(tfidf[i], tfidf[j]) / (norm(tfidf[i]) * norm(tfidf[j]))
        print(f"Doc{i+1} vs Doc{j+1}: {cosine_sim:.4f}")

print("\nEuclidean Distances:")
for i in range(num_docs):
    for j in range(i+1, num_docs):
        euclidean_dist = norm(tfidf[i] - tfidf[j])
        print(f"Doc{i+1} vs Doc{j+1}: {euclidean_dist:.4f}")
